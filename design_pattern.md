#设计模式

### 设计原则
- **单一职责原则**(Single Responsibility Principle, SRP):  
    一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。

- **开闭原则**(Open-Closed Principle, OCP):  
    一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

- **里氏替换原则**(Liskov Substitution Principle, LSP):  
    所有引用基类（父类）的地方必须能透明地使用其子类的对象。

- **依赖倒置原则**(Dependency Inversion  Principle, DIP):  
    抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。

- **接口隔离原则**(Interface  Segregation Principle, ISP):  
    使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。

- **迪米特法则**(Law of  Demeter, LoD):  
    一个软件实体应当尽可能少地与其他实体发生相互作用。  

## 创建型模式
### 单例模式(Singleton Pattern)
### 工厂模式（Factory Method）
### 抽象工厂模式（Abstract Factory）
### 建造者模式（Builder）
### 原型模式（Prototype）


## 结构型模式  

### 代理模式（Proxy）
- 定义：
    代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。
- 作用：
    访问控制
- 动态代理：
    - jdk代理：  
        基于java反射机制。  
        通过接口实现，只能代理接口。
    - CGLib：  
        基于字节码操作，执行效率高，创建效率低，适合作用于单例。  
        通过继承实现，可以代理实现类。无法代理final方法。
    - Spring AOP同时提供了两种实现
- 虚拟代理：  
    在需要的时候初始化代理对象。  
- 远程代理：  
    RMI

### 装饰器模式（Decorator）
- 定义：  
    在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。  
    它是通过创建一个包装对象，也就是装饰来包裹真实的对象。  
- 作用： 
    避免类快速膨胀。
    可以动态地扩展或删除功能。  
- 装饰器和被装饰对象具有相同的超类型。使用装饰器和被装饰对象，都应该拥有一样的体验。  
- jdk的IO包中有大量应用


### 适配器模式（Apater）  
- 定义：  
    将一个接口转换成客户端希望的另一个接口，使接口不兼容的类可以一起工作。
- 作用：  
    解耦
- 类适配器：  
    基于多继承，可以通过重写覆盖，静态
- 对象适配器：  
    基于对象的组合，动态

### 外观模式（Facade）
- 定义：  
    外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
- 作用：  
    减少互相依赖、提供灵活性
- 外观模式并不符合开闭原则

### 组合模式（Composite）
### 桥接模式（Bridge）
### 享元模式（Flyweight）

## 行为型模式
### 模板方法模式（Template Method）
- 定义：  
    定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
- 作用：  
    提炼重复代码，提高复用性。
    父类可以调用子类的操作，符合依赖倒置及开闭原则。
- 基本方法：  
    由子类实现，在模板方法中被调用。
- 模板方法：  
    实现框架，完成固定的逻辑，封装在父类中。
- 基本方法尽量设计为protected，模板方法可以加上final，避免被覆写。

### 策略模式（Strategy）
- 定义：  
    定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化。
- 作用：  
    避免多重条件判断，易拓展。
- 策略需要对外暴露，违背迪米特法则，可配合工厂模式、代理模式优化
- 注意控制策略数量，避免过度膨胀。
- 策略枚举：  
    基于枚举实现，可读性很高，但受枚举类限制，不易拓展。

### 命令模式（Command）
- 定义：  
    将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。
- 角色：  
    - Invoker 调用者：调用者持有一个命令对象，并在某个时刻调用命令对象的 execute() 方法。 
    - Command 命令接口：包含命令对象的 execute() 方法和 undo() 方法。 
    - ConcreteCommand 命令实现：实现命令接口。包括两个操作，执行命令和撤销命令。 
    - Receiver 被调用者：接受命令并执行。
- 可用构建任务队列，提供撤销和重试。
- 宏命令：与组合模式结合
- 应用：线程池、任务队列

### 迭代器模式（Iterator）
- 定义：  
    提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。
- 作用：  
    不暴露集合的数据结构，可灵活替换。

### 责任链模式（Chain of Responsibility）
- 定义：  
    使多个对象都有机会处理同一个请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
- 作用：  
    将请求与执行拆分开。  
- 需注意链长度，避免影响性能。
- 可以动态的修改链行为，但也可能形成循环。
- 应用：  
    - servlet filter：
        在FilterChain中以数组形式维护filter链，见ApplicationFilterChain。
    - netty pipeline：  
        在handler上下文中维护前后节点，见AbstractChannelHandlerContext。
    - dubbo filter：  
        包装在Invoker中，同样以链式结构维护。  
    >TODO：定位源码    
    - mybatis plugin：  
        结合动态代理。
    >TODO：定位源码 

### 观察者模式（Observer）
### 备忘录模式（Memento）
- 定义：  
    在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
- 角色：  
    - Originator发起人：  
        记录内部状态，负责创建和恢复。
    - Memento备忘录：  
        储存内部状态。
    - Caretaker备忘录管理员：
        管理备忘录对象 Caretaker
- 可通过clone方式将Originator与Memento合并，并将Memento保存在Originator内部，省略Caretaker。
- 备忘录需要占用额外空间，需避免频繁创建。

### 状态模式（State）
- 定义：  
    允许一个对象在其内部状态改变的时候改变其行为。外部看像是类做了变化。
- 平行性：  
    各个状态是相互独立的、不可互相替换。


### 访问者模式（Visitor）
- 定义：  
    封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。
### 中介者模式（Mediator）
### 解释器模式（Interpreter）



[^1]:秦小波. 设计模式之禅[M]. 机械工业出版社, 2010.
[^2]:弗里曼. Head First 设计模式: 中文版[M]. 中国电力出版社, 2007.
[^3]:[图说设计模式](https://design-patterns.readthedocs.io/)